{"version":3,"sources":["../../../src/hooks/useCurrentNodeWithPlugin.ts","../../../src/hooks/useRemovePlugin.ts","../../../src/utils/getCurrentData.ts","../../../src/hooks/useAddPlugin.ts","../../../src/components/SlateEditor.tsx","../../../src/components/hotkeyHooks.ts"],"names":["plugin","pluginType"],"mappings":"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","file":"static/js/14.4711b41b.chunk.js","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Editor } from 'slate';\nimport { useSlate } from 'slate-react';\nexport var getCurrentNodeWithPlugin = function (editor, plugin) {\n    if (plugin.pluginType === 'custom') {\n        return null;\n    }\n    var match = plugin.pluginType === 'component'\n        ? plugin.object === 'mark'\n            ? function (elem) { return Boolean(elem[plugin.type]); }\n            : function (elem) { return elem.type === plugin.type; }\n        : plugin.pluginType === 'data'\n            ? // search for data\n                function (_a) {\n                    var data = _a.data;\n                    var matches = plugin.dataMatches(data);\n                    return matches;\n                }\n            : null;\n    try {\n        var _a = __read(Editor.nodes(editor, {\n            match: match,\n            mode: 'lowest',\n        }), 1), matchingNode = _a[0];\n        return matchingNode;\n    }\n    catch (e) {\n        // seems to crash sometimes on redu\n        return null;\n    }\n};\nexport default (function (plugin) {\n    var editor = useSlate();\n    return getCurrentNodeWithPlugin(editor, plugin);\n});\n//# sourceMappingURL=useCurrentNodeWithPlugin.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useCallback } from 'react';\nimport { Transforms } from 'slate';\nimport { useSlate } from 'slate-react';\nimport getCurrentData from '../utils/getCurrentData';\nexport var removePlugin = function (editor, plugin) {\n    if (plugin.customRemove) {\n        plugin.customRemove(editor);\n    }\n    else if (plugin.pluginType === 'component') {\n        if (plugin.object === 'mark') {\n            editor.removeMark(plugin.type);\n        }\n        else if (plugin.object === 'inline') {\n            Transforms.unwrapNodes(editor, {\n                match: function (elem) { return elem.type === plugin.type; },\n            });\n            // Transforms.setNodes(editor, { type: null });\n        }\n        else if (plugin.object === 'block') {\n            if (plugin.replaceWithDefaultOnRemove) {\n                Transforms.setNodes(editor, {\n                    type: null,\n                });\n            }\n            else {\n                Transforms.unwrapNodes(editor, {\n                    match: function (elem) { return elem.type === plugin.type; },\n                    split: true,\n                });\n            }\n        }\n    }\n    else if (plugin.pluginType === 'data') {\n        if (!plugin.properties) {\n            // can't be removed\n        }\n        else {\n            var existingData_1 = getCurrentData(editor);\n            var dataWithout = Object.keys(existingData_1).reduce(function (acc, key) {\n                var _a;\n                if (plugin.properties.includes(key)) {\n                    return acc;\n                }\n                return __assign(__assign({}, acc), (_a = {}, _a[key] = existingData_1[key], _a));\n            }, {});\n            Transforms.setNodes(editor, {\n                data: dataWithout,\n            });\n        }\n    }\n};\nexport default (function (plugin) {\n    var editor = useSlate();\n    return useCallback(function () { return removePlugin(editor, plugin); }, []);\n});\n//# sourceMappingURL=useRemovePlugin.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Editor } from 'slate';\nvar getCurrentData = function (editor) {\n    var _a;\n    var _b = __read(Editor.nodes(editor, {\n        mode: 'all',\n        match: function (node) {\n            return Boolean(node.data);\n        },\n    }), 1), existingNodeWithData = _b[0];\n    var existingData = existingNodeWithData\n        ? (_a = existingNodeWithData[0]) === null || _a === void 0 ? void 0 : _a.data\n        : {};\n    return existingData;\n};\nexport default getCurrentData;\n//# sourceMappingURL=getCurrentData.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useCallback } from 'react';\nimport { Transforms } from 'slate';\nimport { useSlate } from 'slate-react';\nimport { getCurrentNodeWithPlugin } from './useCurrentNodeWithPlugin';\nimport { removePlugin } from './useRemovePlugin';\nimport getCurrentData from '../utils/getCurrentData';\nexport var addPlugin = function (editor, plugin, props) {\n    var _a;\n    var _b = props || {}, passedData = _b.data, text = _b.text;\n    var currentNodeEntry = getCurrentNodeWithPlugin(editor, plugin);\n    if (text) {\n        var withExtraSpace = plugin.pluginType === 'component' &&\n            plugin.object === 'inline' &&\n            plugin.addExtraSpace;\n        var textToInsert = withExtraSpace ? text + ' ' : text;\n        editor.insertText(textToInsert);\n        Transforms.select(editor, {\n            anchor: editor.selection.anchor,\n            focus: __assign(__assign({}, editor.selection.focus), { offset: editor.selection.focus.offset - textToInsert.length }),\n        });\n    }\n    var data = passedData || (plugin.getInitialData ? plugin.getInitialData() : null);\n    var isActive = Boolean(currentNodeEntry);\n    if (isActive) {\n        Transforms.select(editor, currentNodeEntry[1]);\n        removePlugin(editor, plugin);\n    }\n    // add new\n    if (plugin.customAdd) {\n        plugin.customAdd(editor);\n    }\n    else if (plugin.pluginType === 'component') {\n        if (plugin.object === 'mark') {\n            editor.addMark(plugin.type, data || true);\n        }\n        else {\n            if (plugin.object === 'block' && plugin.replaceWithDefaultOnRemove) {\n                Transforms.setNodes(editor, { type: plugin.type, data: data });\n            }\n            else {\n                Transforms.wrapNodes(editor, {\n                    type: plugin.type,\n                    children: [],\n                    data: data,\n                }, { split: true });\n                // workaround for inline problems in slate\n                if (plugin.object === 'inline' &&\n                    plugin.addExtraSpace &&\n                    !text &&\n                    editor.selection) {\n                    var focus_1 = __assign({}, editor.selection.focus);\n                    Transforms.insertText(editor, ' ', {\n                        at: editor.selection.focus,\n                    });\n                    Transforms.select(editor, focus_1);\n                }\n            }\n        }\n    }\n    else if (plugin.pluginType === 'data') {\n        var existingData = (_a = getCurrentData(editor)) !== null && _a !== void 0 ? _a : {};\n        Transforms.setNodes(editor, {\n            data: __assign(__assign({}, existingData), (data !== null && data !== void 0 ? data : {})),\n        });\n    }\n};\nexport default (function (plugin) {\n    var editor = useSlate();\n    return useCallback(function (props) { return addPlugin(editor, plugin, props); }, []);\n});\n//# sourceMappingURL=useAddPlugin.js.map","import { lazyLoad, useUiTranslator } from '@react-page/editor';\nimport React from 'react';\nimport { Editable, useFocused, useSelected } from 'slate-react';\nimport { useDialogIsVisible } from './DialogVisibleProvider';\nimport { useOnKeyDown } from './hotkeyHooks';\nimport { useRenderElement, useRenderLeave } from './renderHooks';\nvar HoverButtons = lazyLoad(function () { return import('./HoverButtons'); });\nvar SlateEditable = React.memo(function (props) {\n    var plugins = props.plugins, defaultPluginType = props.defaultPluginType, readOnly = props.readOnly, placeholder = props.placeholder;\n    var injections = {\n        useSelected: useSelected,\n        useFocused: useFocused,\n    };\n    var renderElement = useRenderElement({ plugins: plugins, defaultPluginType: defaultPluginType, injections: injections }, []);\n    var renderLeaf = useRenderLeave({ plugins: plugins, injections: injections }, []);\n    var onKeyDown = useOnKeyDown({ plugins: plugins }, []);\n    // this is required so that dialogs & controls don't mess with slate's selection\n    var dialogVisible = useDialogIsVisible();\n    return (React.createElement(Editable, { placeholder: readOnly ? undefined : placeholder, readOnly: dialogVisible || readOnly, renderElement: renderElement, renderLeaf: renderLeaf, onKeyDown: readOnly ? undefined : onKeyDown }));\n});\nvar SlateEditor = function (props) {\n    var plugins = props.plugins, focused = props.focused, readOnly = props.readOnly;\n    var t = useUiTranslator().t;\n    return (React.createElement(React.Fragment, null,\n        !readOnly && focused && (React.createElement(HoverButtons, { plugins: props.plugins, translations: props.translations })),\n        React.createElement(SlateEditable, { placeholder: t(props.translations.placeholder), readOnly: readOnly, plugins: plugins, defaultPluginType: props.defaultPluginType })));\n};\nexport default React.memo(SlateEditor);\n//# sourceMappingURL=SlateEditor.js.map","import isHotkey from 'is-hotkey';\nimport React from 'react';\nimport { useSlate } from 'slate-react';\nimport { addPlugin } from '../hooks/useAddPlugin';\nimport { getCurrentNodeWithPlugin } from '../hooks/useCurrentNodeWithPlugin';\nimport { removePlugin } from '../hooks/useRemovePlugin';\nexport var useOnKeyDown = function (_a, deps) {\n    var plugins = _a.plugins;\n    var editor = useSlate();\n    return React.useCallback(function (event) {\n        plugins\n            .filter(function (plugin) { return plugin.hotKey; })\n            .forEach(function (plugin) {\n            if (isHotkey(plugin.hotKey, event)) {\n                event.preventDefault();\n                var node = getCurrentNodeWithPlugin(editor, plugin);\n                if (node) {\n                    removePlugin(editor, plugin);\n                }\n                else {\n                    addPlugin(editor, plugin);\n                }\n            }\n        });\n        // we need to prevent slate from handling undo and redo\n        if (isHotkey(['mod+z', 'mod+y'], event)) {\n            event.preventDefault();\n            return true;\n        }\n        if (isHotkey('shift+enter', event)) {\n            event.preventDefault();\n            editor.insertText('\\n');\n            return true;\n        }\n    }, deps);\n};\n//# sourceMappingURL=hotkeyHooks.js.map"],"sourceRoot":""}