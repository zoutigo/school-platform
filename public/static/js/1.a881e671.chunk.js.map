{"version":3,"sources":["../../../../src/pluginFactories/utils/listUtils.ts"],"names":[],"mappings":"kvBAUa,EAAgB,SAAC,EAAgB,GAK5C,OAJM,EAAiB,SAAO,MAAM,EAAQ,CACtC,MAAG,SAAC,GAAS,SAAa,SAAS,EAAtB,OACjB,KAAM,WACN,GAHiB,IAOR,EAAoB,SAAC,EAAgB,G,QAChD,OAA8C,QAA9C,EAA0C,QAA1C,EAAO,EAAc,EAAQ,UAAa,eAAG,UAAC,eAAG,MAGtC,EAAsB,SAAC,EAAgB,GAC5C,IAAC,EAAD,EAAc,SAAO,MAAM,EAAQ,CACnC,MAAG,SAAC,GAAS,SAAK,OAAL,GACjB,KAAM,WACN,GAHc,GAMd,OADkB,GAAa,EAAU,GAAG,EAAU,GAAG,OAAS,GAAK,EACpD,SAAO,KAAK,EAAQ,OAAK,SAAS,EAAU,KAAO,MAE7D,EAAwB,SACnC,EACA,EACA,GAEE,IAAI,EAAoB,EAAkB,EAAQ,EAAI,cAElD,EAAW,EAAoB,EAAQ,EAAI,cAEjD,aAAW,SAAS,EAAQ,CAC1B,KAAM,EAAI,eAGR,GAEF,aAAW,SACT,EACA,CACE,KAAM,MAER,CACE,GAAI,EAAS,KAKb,EAAJ,WAAW,UACT,EACA,CACE,KAAM,EAAI,aACV,SAAU,IAEZ,CACE,GAAI,EAAS,KAKjB,aAAW,UAAU,EAAQ,CAC3B,GAAE,EAAM,EAAS,GAAE,CAAE,MAEnB,EAAJ,WAAW,UAAU,EAAQ,CAC3B,KAAc,OAAR,QAAQ,IAAR,IAAY,EAClB,SAAU,MAGZ,aAAW,UAAU,EAAQ,CAC3B,KAAc,OAAR,QAAQ,IAAR,IAAY,EAClB,SAAU,MAKV,EAAe,SACnB,EACA,EACA,EACA,G,MAOE,GALA,EAAF,WAAW,UAAU,EAAQ,CACvB,KACA,QAGD,EAAc,CACb,IAAE,EAAa,SAAO,KAAK,EAAQ,IAGjB,QADA,GAAe,OAAV,QAAU,IAAV,OAAU,EAAV,EAAa,IACrC,gBAAmB,eAAE,OACtB,SAAC,GAAU,cAAK,OAAO,IAAU,SAAO,SAAS,EAAtC,OAGX,aAAW,SACT,EACA,CACE,KAAM,MAER,CACE,GAAI,IAIR,aAAW,YAAY,EAAQ,CAC7B,GAAI,MAKC,EAAwB,SAAC,EAAgB,GAC9C,IAgBF,EAZE,EAJA,EAAc,SAAO,MAAM,EAAQ,CACnC,MAAG,SAAC,GAAS,SAAK,OAAS,EAAd,cACb,KAAE,WACN,GAHc,GAIgB,GAC1B,EAAgB,OAAK,OAAO,GAC5B,EAAqB,OAAK,OAAO,GACjC,EAAiB,SAAO,KAAK,EAAQ,GACrC,GAA6B,OAAd,QAAc,IAAd,OAAc,EAAd,EAAiB,GAAG,QAAS,EAAI,aAEhD,EAA+D,IAA5C,EAAc,EAAc,OAAS,GAExD,EAAa,EACf,OAAK,KAAK,GACV,OAAK,KAAK,GAGZ,IACI,EAAG,SAAO,KAAK,EAAQ,CACzB,GAAI,MAIJ,EAAa,EAAQ,EAAK,GAAI,EAAY,SAErC,GAIT,GAFA,EAAa,EAAQ,EAAe,EAAY,GAE5C,IAGF,aAAW,YAAY,EAAQ,CAC7B,GAAI,IAEF,GAAc,CAChB,IAAM,EAAqB,EAAO,OAAK,SAAS,GAAW,CAAE,IACvD,EAAoB,SAAO,KAAK,EAAQ,IAExB,OAAjB,QAAiB,IAAjB,OAAiB,EAAjB,EAAoB,GAAG,OAC1B,aAAW,YAAY,EAAQ,CAC7B,GAAI,EACJ,OAAO","file":"static/js/1.a881e671.chunk.js","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { Editor, Path, Text, Transforms } from 'slate';\nexport var getActiveList = function (editor, allListTypes) {\n    var _a = __read(Editor.nodes(editor, {\n        match: function (elem) { return allListTypes.includes(elem.type); },\n        mode: 'lowest',\n    }), 1), matchingNode = _a[0];\n    return matchingNode;\n};\nexport var getActiveListType = function (editor, allListTypes) {\n    var _a, _b;\n    return (_b = (_a = getActiveList(editor, allListTypes)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.type;\n};\nexport var getPreviousListItem = function (editor, listItemType) {\n    var _a = __read(Editor.nodes(editor, {\n        match: function (elem) { return elem.type === listItemType; },\n        mode: 'lowest',\n    }), 1), currentLi = _a[0];\n    var hasPrevious = currentLi && currentLi[1][currentLi[1].length - 1] > 0;\n    return hasPrevious ? Editor.node(editor, Path.previous(currentLi[1])) : null;\n};\nexport var increaseListIndention = function (editor, def, listType) {\n    var currentActiveType = getActiveListType(editor, def.allListTypes);\n    var previous = getPreviousListItem(editor, def.listItemType);\n    Transforms.setNodes(editor, {\n        type: def.listItemType,\n    });\n    if (previous) {\n        // first make the previous node a paragraph\n        Transforms.setNodes(editor, {\n            type: null,\n        }, {\n            at: previous[1],\n        });\n        // wrap the pararaph as a new list item\n        Transforms.wrapNodes(editor, {\n            type: def.listItemType,\n            children: [],\n        }, {\n            at: previous[1],\n        });\n        // move the current node after the paragraph\n        Transforms.moveNodes(editor, {\n            to: __spread(previous[1], [1]),\n        });\n        Transforms.wrapNodes(editor, {\n            type: listType !== null && listType !== void 0 ? listType : currentActiveType,\n            children: [],\n        });\n    }\n    else {\n        Transforms.wrapNodes(editor, {\n            type: listType !== null && listType !== void 0 ? listType : currentActiveType,\n            children: [],\n        });\n    }\n};\nvar moveToParent = function (editor, nodePath, targetPath, parentIsList) {\n    var _a;\n    Transforms.moveNodes(editor, {\n        at: nodePath,\n        to: targetPath,\n    });\n    if (!parentIsList) {\n        var targetNode = Editor.node(editor, targetPath);\n        // see https://github.com/ianstormtaylor/slate/issues/3769\n        var onlyTextChildren = (_a = (targetNode === null || targetNode === void 0 ? void 0 : targetNode[0])\n            .children) === null || _a === void 0 ? void 0 : _a.every(function (child) { return Text.isText(child) || Editor.isInline(editor, child); });\n        if (onlyTextChildren) {\n            Transforms.setNodes(editor, {\n                type: null,\n            }, {\n                at: targetPath,\n            });\n        }\n        else {\n            Transforms.unwrapNodes(editor, {\n                at: targetPath,\n            });\n        }\n    }\n};\nexport var decreaseListIndention = function (editor, def) {\n    var _a = __read(Editor.nodes(editor, {\n        match: function (elem) { return elem.type === def.listItemType; },\n        mode: 'lowest',\n    }), 1), currentLi = _a[0];\n    var currentLiPath = currentLi[1];\n    var currentParent = Path.parent(currentLiPath);\n    var parentListItemPath = Path.parent(currentParent);\n    var parentListItem = Editor.node(editor, parentListItemPath);\n    var parentIsList = (parentListItem === null || parentListItem === void 0 ? void 0 : parentListItem[0].type) === def.listItemType;\n    var isFirstInItsList = currentLiPath[currentLiPath.length - 1] === 0;\n    var targetPath = parentIsList\n        ? Path.next(parentListItemPath)\n        : Path.next(currentParent);\n    var next;\n    do {\n        next = Editor.next(editor, {\n            at: currentLiPath,\n        });\n        if (next) {\n            moveToParent(editor, next[1], targetPath, parentIsList);\n        }\n    } while (next);\n    moveToParent(editor, currentLiPath, targetPath, parentIsList);\n    if (isFirstInItsList) {\n        // the list will be empty now, remove it\n        Transforms.removeNodes(editor, {\n            at: currentParent,\n        });\n        if (parentIsList) {\n            var previousParagraphPath = __spread(Path.previous(targetPath), [0]);\n            var previousParagraph = Editor.node(editor, previousParagraphPath);\n            if (!(previousParagraph === null || previousParagraph === void 0 ? void 0 : previousParagraph[0].type)) {\n                Transforms.unwrapNodes(editor, {\n                    at: previousParagraphPath,\n                    split: true,\n                });\n            }\n        }\n    }\n};\n//# sourceMappingURL=listUtils.js.map"],"sourceRoot":""}