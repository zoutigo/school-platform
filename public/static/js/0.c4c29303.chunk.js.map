{"version":3,"sources":["../node_modules/slate/node_modules/is-plain-object/index.es.js","../../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../src/utils/weak-maps.ts","../../src/create-editor.ts","../../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../src/utils/string.ts","../../src/interfaces/element.ts","../../src/interfaces/editor.ts","../../src/interfaces/location.ts","../../src/interfaces/node.ts","../../src/interfaces/operation.ts","../../src/interfaces/path.ts","../../src/interfaces/path-ref.ts","../../src/interfaces/point.ts","../../src/interfaces/point-ref.ts","../../src/interfaces/range.ts","../../src/interfaces/range-ref.ts","../../src/interfaces/text.ts","../../src/transforms/node.ts","../../src/transforms/selection.ts","../../src/transforms/text.ts","../../src/transforms/index.ts","../../src/transforms/general.ts","../node_modules/esrever/esrever.js"],"names":["isObjectObject","o","val","Array","isArray","Object","prototype","toString","call","isPlainObject","ctor","prot","constructor","hasOwnProperty","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","DIRTY_PATHS","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","createEditor","editor","children","operations","selection","marks","isInline","isVoid","onChange","apply","op","Editor","PathRef","PointRef","RangeRef","set","dirtyPaths","add","path","oldDirtyPaths","newDirtyPaths","getDirtyPaths","Path","Transforms","Promise","addMark","Range","match","Text","split","deleteBackward","unit","reverse","deleteForward","deleteFragment","direction","getFragment","Node","insertBreak","always","insertFragment","fragment","insertNode","node","insertText","text","inline","n","mode","point","anchor","focus","normalizeNode","entry","Element","at","voids","shouldHaveInlines","i","currentNode","child","prev","isLast","loose","removeMark","levels","descendants","ancestors","previousPath","newPath","oldAncestors","newAncestors","p","newParent","newIndex","resultPath","nextPath","_objectWithoutProperties","source","excluded","target","sourceKeys","keys","length","indexOf","objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","SPACE","PUNCTUATION","CHAMELEON","getCharacterDistance","offset","charCode","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","started","char","l","rest","isWordCharacter","next","remaining","code","SURROGATE_START","isAncestor","isElement","isElementList","isElementProps","props","matches","element","IS_EDITOR_CACHE","above","options","after","edge","range","distance","d","before","edges","end","first","hasBlocks","hasInlines","hasTexts","isBlock","isEditor","cachedIsEditor","Operation","isEnd","Point","isEdge","isEmpty","isNormalizing","isStart","start","last","leaf","isText","block","pointAfterLocation","span","Error","parent","universal","Span","from","to","nodeEntries","pass","isLower","hit","emit","normalize","force","allPaths","dirtyPath","max","m","parentPath","depth","hasPath","pathRef","affinity","ref","current","unref","pathRefs","refs","pointRef","pointRefs","isNewBlock","blockText","leafTextRemaining","leafTextOffset","e","s","reverseText","isFirst","calcDistance","previous","pointBeforeLocation","rangeRef","rangeRefs","string","t","unhangRange","endBlock","blockPath","skip","void","withoutNormalizing","fn","Location","isLocation","isSpan","IS_NODE_LIST_CACHE","ancestor","JSON","c","root","index","childPath","common","descendant","extractProps","produce","r","get","has","isNode","isNodeList","cachedResult","visited","nextIndex","isNodeOperation","isOperation","isOperationList","isSelectionOperation","isTextOperation","inverse","type","inversePath","inverseNewPath","newProperties","properties","paths","another","av","compare","min","Math","endsAfter","as","bs","bv","endsAt","endsBefore","equals","hasPrevious","isAfter","isBefore","isChild","isCommon","isDescendant","isParent","isPath","isSibling","list","relative","transform","operation","position","onp","copy","result","isPoint","includes","isAfterStart","isBeforeEnd","intersection","isBackward","isCollapsed","isExpanded","isForward","isRange","affinityAnchor","affinityFocus","isEqual","omitText","isTextList","isTextProps","decorations","leaves","middle","off","NodeTransforms","insertNodes","hanging","select","nodes","isAtEnd","liftNodes","matchPath","parentNodeEntry","toPath","splitPath","mergeNodes","prevPath","commonPath","isPreviousSibling","emptyAncestor","hasSingleChildNest","emptyRef","prevNode","moveNodes","toRef","targets","removeNodes","depths","setNodes","splitMode","endAtEndOfNode","startAtStartOfNode","k","splitNodes","height","deleteRange","beforeRef","voidMatch","afterPath","voidPath","afterRef","lowestPath","highestPath","unsetNodes","unwrapNodes","wrapNodes","a","commonNodeEntry","wrapperPath","lastPath","wrapper","commonNode","SelectionTransforms","collapse","deselect","move","opts","setPoint","setSelection","oldProps","newProps","TextTransforms","delete","furthestVoid","endOfDoc","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","isInlineStart","isInlineEnd","middleRef","createDraft","truePath","newNode","applyToDraft","finishDraft","isDraft","freeExports","exports","freeGlobal","module","global","window","regexSymbolWithCombiningMarks","regexSurrogatePair","esrever","replace","$0","$1","$2","charAt","define"],"mappings":"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","file":"static/js/0.c4c29303.chunk.js","sourcesContent":["/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport default isPlainObject;\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Transforms.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: (direction?: 'forward' | 'backward') => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, { reverse: direction === 'backward' })\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const currentNode = Node.get(editor, path)\n        if (Text.isText(currentNode)) continue\n        const child = node.children[i] as Descendant\n        const prev = currentNode.children[n - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation): Path[] => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      const newParent = newAncestors[newAncestors.length - 1]\n      const newIndex = newPath[newPath.length - 1]\n      const resultPath = newParent.concat(newIndex)\n\n      return [...oldAncestors, ...newAncestors, resultPath]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path, Descendant, ExtendedType, Ancestor } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface BaseElement {\n  children: Descendant[]\n}\n\nexport type Element = ExtendedType<'Element', BaseElement>\n\nexport interface ElementInterface {\n  isAncestor: (value: any) => value is Ancestor\n  isElement: (value: any) => value is Element\n  isElementList: (value: any) => value is Element[]\n  isElementProps: (props: any) => props is Partial<Element>\n  matches: (element: Element, props: Partial<Element>) => boolean\n}\n\nexport const Element: ElementInterface = {\n  /**\n   * Check if a value implements the 'Ancestor' interface.\n   */\n\n  isAncestor(value: any): value is Ancestor {\n    return isPlainObject(value) && Node.isNodeList(value.children)\n  },\n\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return Array.isArray(value) && value.every(val => Element.isElement(val))\n  },\n\n  /**\n   * Check if a set of props is a partial of Element.\n   */\n\n  isElementProps(props: any): props is Partial<Element> {\n    return (props as Partial<Element>).children !== undefined\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import isPlainObject from 'is-plain-object'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  ExtendedType,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n  Transforms,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\nimport { Descendant } from './node'\nimport { Element } from './element'\n\nexport type BaseSelection = Range | null\n\nexport type Selection = ExtendedType<'Selection', BaseSelection>\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface BaseEditor {\n  children: Descendant[]\n  selection: Selection\n  operations: Operation[]\n  marks: Omit<Text, 'text'> | null\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: (direction?: 'forward' | 'backward') => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport type Editor = ExtendedType<'Editor', BaseEditor>\n\nexport interface EditorInterface {\n  above: <T extends Ancestor>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  addMark: (editor: Editor, key: string, value: any) => void\n  after: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  before: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  deleteBackward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteForward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteFragment: (\n    editor: Editor,\n    options?: {\n      direction?: 'forward' | 'backward'\n    }\n  ) => void\n  edges: (editor: Editor, at: Location) => [Point, Point]\n  end: (editor: Editor, at: Location) => Point\n  first: (editor: Editor, at: Location) => NodeEntry\n  fragment: (editor: Editor, at: Location) => Descendant[]\n  hasBlocks: (editor: Editor, element: Element) => boolean\n  hasInlines: (editor: Editor, element: Element) => boolean\n  hasPath: (editor: Editor, path: Path) => boolean\n  hasTexts: (editor: Editor, element: Element) => boolean\n  insertBreak: (editor: Editor) => void\n  insertFragment: (editor: Editor, fragment: Node[]) => void\n  insertNode: (editor: Editor, node: Node) => void\n  insertText: (editor: Editor, text: string) => void\n  isBlock: (editor: Editor, value: any) => value is Element\n  isEditor: (value: any) => value is Editor\n  isEnd: (editor: Editor, point: Point, at: Location) => boolean\n  isEdge: (editor: Editor, point: Point, at: Location) => boolean\n  isEmpty: (editor: Editor, element: Element) => boolean\n  isInline: (editor: Editor, value: any) => value is Element\n  isNormalizing: (editor: Editor) => boolean\n  isStart: (editor: Editor, point: Point, at: Location) => boolean\n  isVoid: (editor: Editor, value: any) => value is Element\n  last: (editor: Editor, at: Location) => NodeEntry\n  leaf: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Text>\n  levels: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  marks: (editor: Editor) => Omit<Text, 'text'> | null\n  next: <T extends Descendant>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  node: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry\n  nodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  normalize: (\n    editor: Editor,\n    options?: {\n      force?: boolean\n    }\n  ) => void\n  parent: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Ancestor>\n  path: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => Path\n  pathRef: (\n    editor: Editor,\n    path: Path,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PathRef\n  pathRefs: (editor: Editor) => Set<PathRef>\n  point: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      edge?: 'start' | 'end'\n    }\n  ) => Point\n  pointRef: (\n    editor: Editor,\n    point: Point,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PointRef\n  pointRefs: (editor: Editor) => Set<PointRef>\n  positions: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<Point, void, undefined>\n  previous: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  range: (editor: Editor, at: Location, to?: Location) => Range\n  rangeRef: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    }\n  ) => RangeRef\n  rangeRefs: (editor: Editor) => Set<RangeRef>\n  removeMark: (editor: Editor, key: string) => void\n  start: (editor: Editor, at: Location) => Point\n  string: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      voids?: boolean\n    }\n  ) => string\n  unhangRange: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      voids?: boolean\n    }\n  ) => Range\n  void: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<Element> | undefined\n  withoutNormalizing: (editor: Editor, fn: () => void) => void\n}\n\nconst IS_EDITOR_CACHE = new WeakMap<object, boolean>()\n\nexport const Editor: EditorInterface = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(\n    editor: Editor,\n    options: {\n      direction?: 'forward' | 'backward'\n    } = {}\n  ): void {\n    const { direction = 'forward' } = options\n    editor.deleteFragment(direction)\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    if (!isPlainObject(value)) return false\n    const cachedIsEditor = IS_EDITOR_CACHE.get(value)\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor\n    }\n    const isEditor =\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    IS_EDITOR_CACHE.set(value, isEditor)\n    return isEditor\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Omit<Text, 'text'> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Descendant>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointAfterLocation = Editor.after(editor, at, { voids })\n\n    if (!pointAfterLocation) return\n\n    const [, to] = Editor.last(editor, [])\n\n    const span: Span = [pointAfterLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of nodeEntries) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ): void {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\n        Fix dirty elements with no children.\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n        Running an initial pass avoids the catch-22 race condition.\n      */\n      for (const dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          const [node, _] = Editor.node(editor, dirtyPath)\n\n          // Add a text child to elements with no children.\n          // This is safe to do in any order, by definition it can't cause other paths to change.\n          if (Element.isElement(node) && node.children.length === 0) {\n            const child = { text: '' }\n            Transforms.insertNodes(editor, child, {\n              at: dirtyPath.concat(0),\n              voids: true,\n            })\n          }\n        }\n      }\n\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const dirtyPath = getDirtyPaths(editor).pop()!\n\n        // If the node doesn't exist in the tree, it does not need to be normalized.\n        if (Node.has(editor, dirtyPath)) {\n          const entry = Editor.node(editor, dirtyPath)\n          editor.normalizeNode(entry)\n        }\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  hasPath(editor: Editor, path: Path): boolean {\n    return Node.has(editor, path)\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Return all the positions in `at` range where a `Point` can be placed.\n   *\n   * By default, moves forward by individual offsets at a time, but\n   * the `unit` option can be used to to move by character, word, line, or block.\n   *\n   * The `reverse` option can be used to change iteration direction.\n   *\n   * Note: By default void nodes are treated as a single point and iteration\n   * will not happen inside their content unless you pass in true for the\n   * `voids` option, then iteration will occur.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<Point, void, undefined> {\n    const {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let isNewBlock = false\n    let blockText = ''\n    let distance = 0 // Distance for leafText to catch up to blockText.\n    let leafTextRemaining = 0\n    let leafTextOffset = 0\n\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (const [node, path] of Editor.nodes(editor, { at, reverse, voids })) {\n      /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n        if (editor.isInline(node)) continue\n\n        // Block element node - set `blockText` to its text content.\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          blockText = Editor.string(editor, { anchor: s, focus: e }, { voids })\n          blockText = reverse ? reverseText(blockText) : blockText\n          isNewBlock = true\n        }\n      }\n\n      /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n\n        // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n\n        // Reset `leafText` counters for new text node.\n        if (isFirst) {\n          leafTextRemaining = reverse\n            ? first.offset\n            : node.text.length - first.offset\n          leafTextOffset = first.offset // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length\n          leafTextOffset = reverse ? leafTextRemaining : 0\n        }\n\n        // Yield position at the start of node (potentially).\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset: leafTextOffset }\n          isNewBlock = false\n        }\n\n        // Yield positions every (dynamically calculated) `distance` offset.\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break\n            distance = calcDistance(blockText, unit)\n            blockText = blockText.slice(distance)\n          }\n\n          // Advance `leafText` by the current `distance`.\n          leafTextOffset = reverse\n            ? leafTextOffset - distance\n            : leafTextOffset + distance\n          leafTextRemaining = leafTextRemaining - distance\n\n          // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining\n            break\n          }\n\n          // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n          distance = 0\n          yield { path, offset: leafTextOffset }\n        }\n      }\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text: string, unit: string) {\n      if (unit === 'character') {\n        return getCharacterDistance(text)\n      } else if (unit === 'word') {\n        return getWordDistance(text)\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length\n      }\n      return 1\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointBeforeLocation = Editor.before(editor, at, { voids })\n\n    if (!pointBeforeLocation) {\n      return\n    }\n\n    const [, to] = Editor.first(editor, [])\n\n    // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    const span: Span = [pointBeforeLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: by default the text of void nodes is considered to be an empty\n   * string, regardless of content, unless you pass in true for the voids option\n   */\n\n  string(\n    editor: Editor,\n    at: Location,\n    options: {\n      voids?: boolean\n    } = {}\n  ): string {\n    const { voids = false } = options\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    try {\n      fn()\n    } finally {\n      NORMALIZING.set(editor, value)\n    }\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\nexport type NodeMatch<T extends Node> =\n  | ((node: Node, path: Path) => node is T)\n  | ((node: Node, path: Path) => boolean)\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport interface LocationInterface {\n  isLocation: (value: any) => value is Location\n}\n\nexport const Location: LocationInterface = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport interface SpanInterface {\n  isSpan: (value: any) => value is Span\n}\n\nexport const Span: SpanInterface = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Path, Range, Text } from '..'\nimport { Element, ElementEntry } from './element'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type BaseNode = Editor | Element | Text\nexport type Node = Editor | Element | Text\n\nexport interface NodeInterface {\n  ancestor: (root: Node, path: Path) => Ancestor\n  ancestors: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Ancestor>, void, undefined>\n  child: (root: Node, index: number) => Descendant\n  children: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  common: (root: Node, path: Path, another: Path) => NodeEntry\n  descendant: (root: Node, path: Path) => Descendant\n  descendants: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  elements: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<ElementEntry, void, undefined>\n  extractProps: (node: Node) => NodeProps\n  first: (root: Node, path: Path) => NodeEntry\n  fragment: (root: Node, range: Range) => Descendant[]\n  get: (root: Node, path: Path) => Node\n  has: (root: Node, path: Path) => boolean\n  isNode: (value: any) => value is Node\n  isNodeList: (value: any) => value is Node[]\n  last: (root: Node, path: Path) => NodeEntry\n  leaf: (root: Node, path: Path) => Text\n  levels: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  matches: (node: Node, props: Partial<Node>) => boolean\n  nodes: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  parent: (root: Node, path: Path) => Ancestor\n  string: (node: Node) => string\n  texts: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Text>, void, undefined>\n}\n\nconst IS_NODE_LIST_CACHE = new WeakMap<any[], boolean>()\n\nexport const Node: NodeInterface = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Extract props from a Node.\n   */\n\n  extractProps(node: Node): NodeProps {\n    if (Element.isAncestor(node)) {\n      const { children, ...properties } = node\n\n      return properties\n    } else {\n      const { text, ...properties } = node\n\n      return properties\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce({ children: root.children }, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null\n      }\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    if (!Array.isArray(value)) {\n      return false\n    }\n    const cachedResult = IS_NODE_LIST_CACHE.get(value)\n    if (cachedResult !== undefined) {\n      return cachedResult\n    }\n    const isNodeList = value.every(val => Node.isNode(val))\n    IS_NODE_LIST_CACHE.set(value, isNodeList)\n    return isNodeList\n  },\n\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) &&\n        Element.isElementProps(props) &&\n        Element.matches(node, props)) ||\n      (Text.isText(node) &&\n        Text.isTextProps(props) &&\n        Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't descended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n\n/**\n * Convenience type for returning the props of a node.\n */\nexport type NodeProps =\n  | Omit<Editor, 'children'>\n  | Omit<Element, 'children'>\n  | Omit<Text, 'text'>\n","import { ExtendedType, Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type BaseInsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n}\n\nexport type InsertNodeOperation = ExtendedType<\n  'InsertNodeOperation',\n  BaseInsertNodeOperation\n>\n\nexport type BaseInsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type InsertTextOperation = ExtendedType<\n  'InsertTextOperation',\n  BaseInsertTextOperation\n>\n\nexport type BaseMergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type MergeNodeOperation = ExtendedType<\n  'MergeNodeOperation',\n  BaseMergeNodeOperation\n>\n\nexport type BaseMoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n}\n\nexport type MoveNodeOperation = ExtendedType<\n  'MoveNodeOperation',\n  BaseMoveNodeOperation\n>\n\nexport type BaseRemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n}\n\nexport type RemoveNodeOperation = ExtendedType<\n  'RemoveNodeOperation',\n  BaseRemoveNodeOperation\n>\n\nexport type BaseRemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type RemoveTextOperation = ExtendedType<\n  'RemoveTextOperation',\n  BaseRemoveTextOperation\n>\n\nexport type BaseSetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n}\n\nexport type SetNodeOperation = ExtendedType<\n  'SetNodeOperation',\n  BaseSetNodeOperation\n>\n\nexport type BaseSetSelectionOperation =\n  | {\n      type: 'set_selection'\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      properties: Range\n      newProperties: null\n    }\n\nexport type SetSelectionOperation = ExtendedType<\n  'SetSelectionOperation',\n  BaseSetSelectionOperation\n>\n\nexport type BaseSplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type SplitNodeOperation = ExtendedType<\n  'SplitNodeOperation',\n  BaseSplitNodeOperation\n>\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport interface OperationInterface {\n  isNodeOperation: (value: any) => value is NodeOperation\n  isOperation: (value: any) => value is Operation\n  isOperationList: (value: any) => value is Operation[]\n  isSelectionOperation: (value: any) => value is SelectionOperation\n  isTextOperation: (value: any) => value is TextOperation\n  inverse: (op: Operation) => Operation\n}\n\nexport const Operation: OperationInterface = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) && value.every(val => Operation.isOperation(val))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport interface PathInterface {\n  ancestors: (path: Path, options?: { reverse?: boolean }) => Path[]\n  common: (path: Path, another: Path) => Path\n  compare: (path: Path, another: Path) => -1 | 0 | 1\n  endsAfter: (path: Path, another: Path) => boolean\n  endsAt: (path: Path, another: Path) => boolean\n  endsBefore: (path: Path, another: Path) => boolean\n  equals: (path: Path, another: Path) => boolean\n  hasPrevious: (path: Path) => boolean\n  isAfter: (path: Path, another: Path) => boolean\n  isAncestor: (path: Path, another: Path) => boolean\n  isBefore: (path: Path, another: Path) => boolean\n  isChild: (path: Path, another: Path) => boolean\n  isCommon: (path: Path, another: Path) => boolean\n  isDescendant: (path: Path, another: Path) => boolean\n  isParent: (path: Path, another: Path) => boolean\n  isPath: (value: any) => value is Path\n  isSibling: (path: Path, another: Path) => boolean\n  levels: (\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Path[]\n  next: (path: Path) => Path\n  parent: (path: Path) => Path\n  previous: (path: Path) => Path\n  relative: (path: Path, ancestor: Path) => Path\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Path | null\n}\n\nexport const Path: PathInterface = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if the path of previous sibling node exists\n   */\n\n  hasPrevious(path: Path): boolean {\n    return path[path.length - 1] > 0\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport interface PathRefInterface {\n  transform: (ref: PathRef, op: Operation) => void\n}\n\nexport const PathRef: PathRefInterface = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { ExtendedType, Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface BasePoint {\n  path: Path\n  offset: number\n}\n\nexport type Point = ExtendedType<'Point', BasePoint>\n\nexport interface PointInterface {\n  compare: (point: Point, another: Point) => -1 | 0 | 1\n  isAfter: (point: Point, another: Point) => boolean\n  isBefore: (point: Point, another: Point) => boolean\n  equals: (point: Point, another: Point) => boolean\n  isPoint: (value: any) => value is Point\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Point | null\n}\n\nexport const Point: PointInterface = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport interface PointRefInterface {\n  transform: (ref: PointRef, op: Operation) => void\n}\n\nexport const PointRef: PointRefInterface = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { ExtendedType, Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface BaseRange {\n  anchor: Point\n  focus: Point\n}\n\nexport type Range = ExtendedType<'Range', BaseRange>\n\nexport interface RangeInterface {\n  edges: (\n    range: Range,\n    options?: {\n      reverse?: boolean\n    }\n  ) => [Point, Point]\n  end: (range: Range) => Point\n  equals: (range: Range, another: Range) => boolean\n  includes: (range: Range, target: Path | Point | Range) => boolean\n  intersection: (range: Range, another: Range) => Range | null\n  isBackward: (range: Range) => boolean\n  isCollapsed: (range: Range) => boolean\n  isExpanded: (range: Range) => boolean\n  isForward: (range: Range) => boolean\n  isRange: (value: any) => value is Range\n  points: (range: Range) => Generator<PointEntry, void, undefined>\n  start: (range: Range) => Point\n  transform: (\n    range: Range,\n    op: Operation,\n    options?: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    }\n  ) => Range | null\n}\n\nexport const Range: RangeInterface = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    } = {}\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport interface RangeRefInterface {\n  transform: (ref: RangeRef, op: Operation) => void\n}\n\nexport const RangeRef: RangeRefInterface = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport isEqual from 'fast-deep-equal'\nimport { Range } from '..'\nimport { ExtendedType } from './custom-types'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface BaseText {\n  text: string\n}\n\nexport type Text = ExtendedType<'Text', BaseText>\n\nexport interface TextInterface {\n  equals: (text: Text, another: Text, options?: { loose?: boolean }) => boolean\n  isText: (value: any) => value is Text\n  isTextList: (value: any) => value is Text[]\n  isTextProps: (props: any) => props is Partial<Text>\n  matches: (text: Text, props: Partial<Text>) => boolean\n  decorations: (node: Text, decorations: Range[]) => Text[]\n}\n\nexport const Text: TextInterface = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    function omitText(obj: Record<any, any>) {\n      const { text, ...rest } = obj\n\n      return rest\n    }\n\n    return isEqual(\n      loose ? omitText(text) : text,\n      loose ? omitText(another) : another\n    )\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && value.every(val => Text.isText(val))\n  },\n\n  /**\n   * Check if some props are a partial of Text.\n   */\n\n  isTextProps(props: any): props is Partial<Text> {\n    return (props as Partial<Text>).text !== undefined\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= o) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (\n          (start.offset !== end.offset &&\n            (start.offset === o || end.offset === offset)) ||\n          start.offset > o ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < o) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\nimport { NodeMatch } from '../interfaces/editor'\n\nexport interface NodeTransforms {\n  insertNodes: <T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    }\n  ) => void\n  liftNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => void\n  mergeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  moveNodes: <T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) => void\n  removeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  setNodes: <T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  splitNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    }\n  ) => void\n  unsetNodes: <T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  unwrapNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  wrapNodes: <T extends Node>(\n    editor: Editor,\n    element: Element,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const NodeTransforms: NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes<T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n),\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n\n        if (\n          toRef.current &&\n          Path.isSibling(newPath, path) &&\n          Path.isAfter(newPath, path)\n        ) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current)\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes<T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        const endAtEndOfNode = Editor.isEnd(editor, end, end.path)\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode,\n        })\n        const startAtStartOfNode = Editor.isStart(editor, start, start.path)\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            // Omit new properties from the old property list rather than set them to undefined\n            if (node.hasOwnProperty(k)) properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const properties = Node.extractProps(node)\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes<T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path)\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes<T extends Node>(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n =>\n              Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\nconst hasSingleChildNest = (editor: Editor, node: Node): boolean => {\n  if (Element.isElement(node)) {\n    const element = node as Element\n    if (Editor.isVoid(editor, node)) {\n      return true\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0])\n    } else {\n      return false\n    }\n  } else if (Editor.isEditor(node)) {\n    return false\n  } else {\n    return true\n  }\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport interface SelectionTransforms {\n  collapse: (\n    editor: Editor,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  deselect: (editor: Editor) => void\n  move: (\n    editor: Editor,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  select: (editor: Editor, target: Location) => void\n  setPoint: (\n    editor: Editor,\n    props: Partial<Point>,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  setSelection: (editor: Editor, props: Partial<Range>) => void\n}\n\nexport const SelectionTransforms: SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location): void {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>): void {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport interface TextTransforms {\n  delete: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertFragment: (\n    editor: Editor,\n    fragment: Node[],\n    options?: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertText: (\n    editor: Editor,\n    text: string,\n    options?: {\n      at?: Location\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const TextTransforms: TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        const [, end] = Range.edges(at)\n        const endOfDoc = Editor.end(editor, [])\n\n        if (!Point.equals(end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, { voids })\n        }\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = reverse\n        ? startRef.unref() || endRef.unref()\n        : endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      if (text.length > 0)\n        editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms: GeneralTransforms &\n  NodeTransforms &\n  SelectionTransforms &\n  TextTransforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Selection,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport interface GeneralTransforms {\n  transform: (editor: Editor, op: Operation) => void\n}\n\nconst applyToDraft = (editor: Editor, selection: Selection, op: Operation) => {\n  switch (op.type) {\n    case 'insert_node': {\n      const { path, node } = op\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (index > parent.children.length) {\n        throw new Error(\n          `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n        )\n      }\n\n      parent.children.splice(index, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'insert_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset)\n      node.text = before + text + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const node = Node.get(editor, path)\n      const prevPath = Path.previous(path)\n      const prev = Node.get(editor, prevPath)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (Text.isText(node) && Text.isText(prev)) {\n        prev.text += node.text\n      } else if (!Text.isText(node) && !Text.isText(prev)) {\n        prev.children.push(...node.children)\n      } else {\n        throw new Error(\n          `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interfaces: ${node} ${prev}`\n        )\n      }\n\n      parent.children.splice(index, 1)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.isAncestor(path, newPath)) {\n        throw new Error(\n          `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      // This is tricky, but since the `path` and `newPath` both refer to\n      // the same snapshot in time, there's a mismatch. After either\n      // removing the original position, the second step's path can be out\n      // of date. So instead of using the `op.newPath` directly, we\n      // transform `op.path` to ascertain what the `newPath` would be after\n      // the operation was applied.\n      parent.children.splice(index, 1)\n      const truePath = Path.transform(path, op)!\n      const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n      const newIndex = truePath[truePath.length - 1]\n\n      newParent.children.splice(newIndex, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const index = path[path.length - 1]\n      const parent = Node.parent(editor, path)\n      parent.children.splice(index, 1)\n\n      // Transform all of the points in the value, but if the point was in the\n      // node that was removed we need to update the range or remove it.\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          const result = Point.transform(point, op)\n\n          if (selection != null && result != null) {\n            selection[key] = result\n          } else {\n            let prev: NodeEntry<Text> | undefined\n            let next: NodeEntry<Text> | undefined\n\n            for (const [n, p] of Node.texts(editor)) {\n              if (Path.compare(p, path) === -1) {\n                prev = [n, p]\n              } else {\n                next = [n, p]\n                break\n              }\n            }\n\n            if (prev) {\n              point.path = prev[1]\n              point.offset = prev[0].text.length\n            } else if (next) {\n              point.path = next[1]\n              point.offset = 0\n            } else {\n              selection = null\n            }\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset + text.length)\n      node.text = before + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'set_node': {\n      const { path, properties, newProperties } = op\n\n      if (path.length === 0) {\n        throw new Error(`Cannot set properties on the root node!`)\n      }\n\n      const node = Node.get(editor, path)\n\n      for (const key in newProperties) {\n        if (key === 'children' || key === 'text') {\n          throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n        }\n\n        const value = newProperties[key]\n\n        if (value == null) {\n          delete node[key]\n        } else {\n          node[key] = value\n        }\n      }\n\n      // properties that were previously defined, but are now missing, must be deleted\n      for (const key in properties) {\n        if (!newProperties.hasOwnProperty(key)) {\n          delete node[key]\n        }\n      }\n\n      break\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n\n      if (newProperties == null) {\n        selection = newProperties\n      } else {\n        if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = { ...newProperties }\n        }\n\n        for (const key in newProperties) {\n          const value = newProperties[key]\n\n          if (value == null) {\n            if (key === 'anchor' || key === 'focus') {\n              throw new Error(`Cannot remove the \"${key}\" selection property`)\n            }\n\n            delete selection[key]\n          } else {\n            selection[key] = value\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n\n      if (path.length === 0) {\n        throw new Error(\n          `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n      let newNode: Descendant\n\n      if (Text.isText(node)) {\n        const before = node.text.slice(0, position)\n        const after = node.text.slice(position)\n        node.text = before\n        newNode = {\n          ...(properties as Partial<Text>),\n          text: after,\n        }\n      } else {\n        const before = node.children.slice(0, position)\n        const after = node.children.slice(position)\n        node.children = before\n\n        newNode = {\n          ...(properties as Partial<Element>),\n          children: after,\n        }\n      }\n\n      parent.children.splice(index + 1, 0, newNode)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n  }\n  return selection\n}\n\nexport const GeneralTransforms: GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation): void {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    try {\n      selection = applyToDraft(editor, selection, op)\n    } finally {\n      editor.children = finishDraft(editor.children)\n\n      if (selection) {\n        editor.selection = isDraft(selection)\n          ? (finishDraft(selection) as Range)\n          : selection\n      } else {\n        editor.selection = null\n      }\n    }\n  },\n}\n","/*! https://mths.be/esrever v0.2.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n\tvar regexSurrogatePair = /([\\uD800-\\uDBFF])([\\uDC00-\\uDFFF])/g;\n\n\tvar reverse = function(string) {\n\t\t// Step 1: deal with combining marks and astral symbols (surrogate pairs)\n\t\tstring = string\n\t\t\t// Swap symbols with their combining marks so the combining marks go first\n\t\t\t.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {\n\t\t\t\t// Reverse the combining marks so they will end up in the same order\n\t\t\t\t// later on (after another round of reversing)\n\t\t\t\treturn reverse($2) + $1;\n\t\t\t})\n\t\t\t// Swap high and low surrogates so the low surrogates go first\n\t\t\t.replace(regexSurrogatePair, '$2$1');\n\t\t// Step 2: reverse the code units in the string\n\t\tvar result = '';\n\t\tvar index = string.length;\n\t\twhile (index--) {\n\t\t\tresult += string.charAt(index);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar esrever = {\n\t\t'version': '0.2.0',\n\t\t'reverse': reverse\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn esrever;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = esrever;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in esrever) {\n\t\t\t\tesrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.esrever = esrever;\n\t}\n\n}(this));\n"],"sourceRoot":""}